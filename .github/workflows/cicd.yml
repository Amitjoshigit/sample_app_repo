
name: CI-CD-Infra-ArgoCD

on:
  push:
    branches:
      - main
      - develop

env:
  AWS_ACCOUNT_ID: "993326153624"
  AWS_REGION: "ap-south-1"
  ECR_REPOSITORY: "backstage"
  EKS_CLUSTER: "backstage"
  KUBERNETES_NAMESPACE: "backstage"
  PROJECT_NAME: "backstage"
  ENVIRONMENT: "dev"

jobs:
  terraform:
    name: Terraform Provision Infra
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    outputs:
      ecr_url: ${{ steps.tf-outputs.outputs.ecr_url }}
      eks_name: ${{ steps.tf-outputs.outputs.eks_name }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::993326153624:role/backstage
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: github-actions-terraform

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.2
          terraform_wrapper: false

      - name: Bootstrap Backend
        run: |
          BUCKET_NAME="${{ env.PROJECT_NAME }}-terraform-state-${{ env.AWS_ACCOUNT_ID }}"
          TABLE_NAME="terraform-locks-${{ env.PROJECT_NAME }}"

          echo "Checking S3 bucket: $BUCKET_NAME"
          if ! aws s3api head-bucket --bucket "$BUCKET_NAME" 2>/dev/null; then
            echo "Creating S3 bucket..."
            aws s3api create-bucket \
              --bucket "$BUCKET_NAME" \
              --region ${{ env.AWS_REGION }} \
              --create-bucket-configuration LocationConstraint=${{ env.AWS_REGION }}

            aws s3api put-bucket-versioning \
              --bucket "$BUCKET_NAME" \
              --versioning-configuration Status=Enabled

            aws s3api put-bucket-encryption \
              --bucket "$BUCKET_NAME" \
              --server-side-encryption-configuration '{"Rules":[{"ApplyServerSideEncryptionByDefault":{"SSEAlgorithm":"AES256"}}]}'
          else
            echo "S3 bucket already exists"
          fi

          echo "Checking DynamoDB table: $TABLE_NAME"
          if ! aws dynamodb describe-table --table-name "$TABLE_NAME" --region ${{ env.AWS_REGION }} 2>/dev/null; then
            echo "Creating DynamoDB table..."
            aws dynamodb create-table \
              --table-name "$TABLE_NAME" \
              --attribute-definitions AttributeName=LockID,AttributeType=S \
              --key-schema AttributeName=LockID,KeyType=HASH \
              --billing-mode PAY_PER_REQUEST \
              --region ${{ env.AWS_REGION }}

            aws dynamodb wait table-exists --table-name "$TABLE_NAME" --region ${{ env.AWS_REGION }}
          else
            echo "DynamoDB table already exists"
          fi

          echo "Checking ECR repository: ${{ env.ECR_REPOSITORY }}"
          if ! aws ecr describe-repositories --repository-names ${{ env.ECR_REPOSITORY }} --region ${{ env.AWS_REGION }} 2>/dev/null; then
            echo "Creating ECR repository..."
            aws ecr create-repository \
              --repository-name ${{ env.ECR_REPOSITORY }} \
              --region ${{ env.AWS_REGION }} \
              --image-scanning-configuration scanOnPush=true \
              --encryption-configuration encryptionType=AES256
          else
            echo "ECR repository already exists"
          fi

          echo "BUCKET_NAME=$BUCKET_NAME" >> $GITHUB_ENV
          echo "TABLE_NAME=$TABLE_NAME" >> $GITHUB_ENV

      - name: Initialize Terraform
        working-directory: ./infra
        run: |
          terraform init \
            -backend-config="bucket=${{ env.BUCKET_NAME }}" \
            -backend-config="key=terraform.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}" \
            -backend-config="dynamodb_table=${{ env.TABLE_NAME }}" \
            -reconfigure

      - name: Terraform Validate
        working-directory: ./infra
        run: terraform validate

      - name: Terraform Plan
        working-directory: ./infra
        run: |
          terraform plan \
            -var="aws_region=${{ env.AWS_REGION }}" \
            -var="project_name=${{ env.PROJECT_NAME }}" \
            -var="environment=${{ env.ENVIRONMENT }}" \
            -out=tfplan

      - name: Terraform Apply
        if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop'
        working-directory: ./infra
        run: terraform apply -auto-approve tfplan

      - name: Capture Outputs
        id: tf-outputs
        working-directory: ./infra
        run: |
          ECR_URL=$(terraform output -raw ecr_repository_url 2>/dev/null || echo "")
          EKS_NAME=$(terraform output -raw cluster_name 2>/dev/null || echo "${{ env.EKS_CLUSTER }}")

          echo "ecr_url=$ECR_URL" >> $GITHUB_OUTPUT
          echo "eks_name=$EKS_NAME" >> $GITHUB_OUTPUT

          echo "ECR Repository: $ECR_URL"
          echo "EKS Cluster: $EKS_NAME"

  build-push:
    name: Build & Push Docker Image
    runs-on: ubuntu-latest
    needs: terraform
    permissions:
      id-token: write
      contents: read
    outputs:
      image_uri: ${{ steps.build.outputs.image_uri }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Install dependencies
        run: yarn install --frozen-lockfile

      - name: Build application
        run: yarn build

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::993326153624:role/backstage
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build, Tag & Push
        id: build
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ env.ECR_REPOSITORY }}
        run: |
          IMAGE_TAG=${{ github.sha }}
          IMAGE_URI=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG

          echo "Building image: $IMAGE_URI"
          docker build -t $IMAGE_URI .
          docker push $IMAGE_URI

          echo "Tagging as latest..."
          docker tag $IMAGE_URI $ECR_REGISTRY/$ECR_REPOSITORY:latest
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest

          echo "image_uri=$IMAGE_URI" >> $GITHUB_OUTPUT

  update-manifests:
    name: Update K8s Manifests
    runs-on: ubuntu-latest
    needs: build-push
    if: github.ref == 'refs/heads/main'
    permissions:
      contents: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Create manifests
        run: |
          mkdir -p k8s/base

          cat > k8s/base/namespace.yaml <<'EOFNS'
          apiVersion: v1
          kind: Namespace
          metadata:
            name: backstage
          EOFNS

          cat > k8s/base/deployment.yaml <<'EOFDEP'
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: backstage
            namespace: backstage
          spec:
            replicas: 2
            selector:
              matchLabels:
                app: backstage
            template:
              metadata:
                labels:
                  app: backstage
              spec:
                containers:
                  - name: backstage
                    image: 993326153624.dkr.ecr.ap-south-1.amazonaws.com/backstage:latest
                    ports:
                      - containerPort: 80
                        name: http
                    resources:
                      requests:
                        memory: "512Mi"
                        cpu: "250m"
                      limits:
                        memory: "1Gi"
                        cpu: "500m"
          EOFDEP

          cat > k8s/base/service.yaml <<'EOFSVC'
          apiVersion: v1
          kind: Service
          metadata:
            name: backstage
            namespace: backstage
          spec:
            type: LoadBalancer
            selector:
              app: backstage
            ports:
              - name: http
                port: 80
                targetPort: 80
          EOFSVC

      - name: Update image tag
        run: |
          IMAGE_URI="${{ needs.build-push.outputs.image_uri }}"
          echo "Updating deployment with: $IMAGE_URI"
          sed -i "s|image:.*backstage:.*|image: $IMAGE_URI|" k8s/base/deployment.yaml

      - name: Commit and push
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git add k8s/

          if ! git diff --staged --quiet; then
            git commit -m "Update deployment image to ${{ github.sha }} [skip ci]"
            git push
          else
            echo "No changes to commit"
          fi

  deploy:
    name: Deploy to EKS via ArgoCD
    runs-on: ubuntu-latest
    needs:
      - terraform
      - build-push
      - update-manifests
    if: github.ref == 'refs/heads/main'
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::993326153624:role/backstage
          aws-region: ${{ env.AWS_REGION }}

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig \
            --region ${{ env.AWS_REGION }} \
            --name ${{ env.EKS_CLUSTER }}

          echo "Cluster info:"
          kubectl cluster-info

      - name: Install ArgoCD
        run: |
          kubectl create namespace argocd --dry-run=client -o yaml | kubectl apply -f -

          if ! kubectl get deploy -n argocd argocd-server >/dev/null 2>&1; then
            echo "Installing ArgoCD..."
            kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml

            echo "Waiting for ArgoCD to be ready..."
            kubectl wait --for=condition=available --timeout=600s -n argocd deployment/argocd-server

            echo "ArgoCD installed successfully"
          else
            echo "ArgoCD already installed"
          fi

      - name: Deploy Application
        run: |
          cat > argocd-app.yaml <<'EOFARGO'
          apiVersion: argoproj.io/v1alpha1
          kind: Application
          metadata:
            name: backstage-app
            namespace: argocd
          spec:
            project: default
            source:
              repoURL: https://github.com/${{ github.repository }}
              targetRevision: main
              path: k8s/base
              directory:
                recurse: true
            destination:
              server: https://kubernetes.default.svc
              namespace: backstage
            syncPolicy:
              automated:
                prune: true
                selfHeal: true
              syncOptions:
                - CreateNamespace=true
          EOFARGO

          kubectl apply -f argocd-app.yaml

      - name: Wait for sync
        run: |
          echo "Waiting for ArgoCD to sync application..."

          for i in {1..30}; do
            STATUS=$(kubectl get application backstage-app -n argocd -o jsonpath='{.status.sync.status}' 2>/dev/null || echo "Unknown")
            HEALTH=$(kubectl get application backstage-app -n argocd -o jsonpath='{.status.health.status}' 2>/dev/null || echo "Unknown")

            echo "[$i/30] Sync: $STATUS | Health: $HEALTH"

            if [[ "$STATUS" == "Synced" && "$HEALTH" == "Healthy" ]]; then
              echo "Application synced and healthy!"
              break
            fi

            sleep 10
          done

      - name: Get ArgoCD Password
        run: |
          echo ""
          echo "================================"
          echo "ArgoCD Admin Credentials"
          echo "================================"
          echo "Username: admin"
          echo -n "Password: "
          kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 --decode
          echo ""
          echo ""
          echo "Access ArgoCD UI:"
          echo "  kubectl port-forward svc/argocd-server -n argocd 8080:443"
          echo "  Then open: https://localhost:8080"
          echo "================================"

      - name: Deployment Summary
        run: |
          echo ""
          echo "================================"
          echo "Deployment Summary"
          echo "================================"
          echo ""
          echo "Backstage Resources:"
          kubectl get all -n backstage
          echo ""
          echo "ArgoCD Application Status:"
          kubectl get application -n argocd backstage-app -o wide
          echo ""
          echo "================================"
